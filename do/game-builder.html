<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>package builder ‚Äì winded.vertigo</title>
  <meta name="description" content="Build your custom learning experience package at the winded.vertigo apothecary.">

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* =============================================
       WINDED.VERTIGO BRAND PALETTE
       ============================================= */

    :root {
      --cadet-blue: #273248;
      --redwood: #b15043;
      --burnt-sienna: #cb7858;
      --champagne: #ffebd2;
      --white: #ffffff;
      --periwinkle: #5872cb;
      --seafoam: #58cbb2;
      --light-lavender: #d5d2ff;
      --light-cyan: #d2fdff;

      --font-display: 'Space Mono', monospace;
      --font-ui: 'Inter', sans-serif;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font-ui);
      background: #1a1510;
      color: var(--champagne);
    }

    /* =============================================
       LAYOUT
       ============================================= */

    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #scene-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* =============================================
       HEADER OVERLAY
       ============================================= */

    .header-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: linear-gradient(180deg, rgba(26, 21, 16, 0.95) 0%, transparent 100%);
      pointer-events: none;
    }

    .header-overlay > * {
      pointer-events: auto;
    }

    .shop-title {
      font-family: var(--font-display);
      font-size: 14px;
      color: var(--champagne);
      letter-spacing: 2px;
      text-transform: lowercase;
    }

    .step-indicator {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .step-pip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid var(--burnt-sienna);
      background: transparent;
      transition: all 0.3s ease;
    }

    .step-pip.active {
      background: var(--burnt-sienna);
      box-shadow: 0 0 10px var(--burnt-sienna);
    }

    .step-pip.complete {
      background: var(--seafoam);
      border-color: var(--seafoam);
    }

    .exit-btn {
      font-family: var(--font-display);
      font-size: 12px;
      color: var(--champagne);
      background: none;
      border: 1px solid var(--burnt-sienna);
      padding: 8px 16px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .exit-btn:hover {
      background: var(--burnt-sienna);
      color: var(--cadet-blue);
    }

    /* =============================================
       INVENTORY POUCH (Zelda-style)
       ============================================= */

    .inventory-pouch {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 20;
      width: 320px;
      background: linear-gradient(145deg, #2a2318 0%, #1a1510 100%);
      border: 3px solid var(--burnt-sienna);
      border-radius: 12px;
      padding: 16px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 235, 210, 0.1);
    }

    .pouch-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(203, 120, 88, 0.3);
    }

    .pouch-title {
      font-family: var(--font-display);
      font-size: 11px;
      color: var(--burnt-sienna);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .pouch-subtitle {
      font-size: 10px;
      color: var(--champagne);
      opacity: 0.6;
    }

    .inventory-section {
      margin-bottom: 12px;
    }

    .inventory-section:last-child {
      margin-bottom: 0;
    }

    .section-label {
      font-family: var(--font-display);
      font-size: 9px;
      color: var(--champagne);
      opacity: 0.5;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .slot-row {
      display: flex;
      gap: 8px;
    }

    .inventory-slot {
      width: 48px;
      height: 48px;
      background: rgba(39, 50, 72, 0.4);
      border: 2px solid rgba(203, 120, 88, 0.3);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      position: relative;
    }

    .inventory-slot.single {
      width: 100%;
      max-width: 80px;
    }

    .inventory-slot.drop-target {
      border-color: var(--seafoam);
      background: rgba(88, 203, 178, 0.15);
      box-shadow: 0 0 15px rgba(88, 203, 178, 0.3);
    }

    .inventory-slot.filled {
      border-color: var(--burnt-sienna);
      background: rgba(203, 120, 88, 0.15);
    }

    .slot-item {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .slot-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--cadet-blue);
      color: var(--champagne);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .inventory-slot:hover .slot-tooltip {
      opacity: 1;
    }

    /* =============================================
       STAGE PROMPT OVERLAY
       ============================================= */

    .stage-prompt {
      position: absolute;
      top: 80px;
      left: 24px;
      z-index: 15;
      max-width: 300px;
      background: rgba(26, 21, 16, 0.9);
      border-left: 3px solid var(--burnt-sienna);
      padding: 16px;
      border-radius: 0 8px 8px 0;
    }

    .prompt-step {
      font-family: var(--font-display);
      font-size: 10px;
      color: var(--burnt-sienna);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .prompt-question {
      font-size: 16px;
      font-weight: 500;
      color: var(--champagne);
      margin-bottom: 8px;
    }

    .prompt-hint {
      font-size: 12px;
      color: var(--champagne);
      opacity: 0.6;
    }

    .prompt-hint em {
      color: var(--seafoam);
      font-style: normal;
    }

    /* =============================================
       ITEM LABELS (floating in 3D space)
       ============================================= */

    .item-label {
      position: absolute;
      background: rgba(26, 21, 16, 0.9);
      border: 1px solid var(--burnt-sienna);
      padding: 6px 10px;
      border-radius: 4px;
      pointer-events: none;
      z-index: 25;
      transform: translate(-50%, -100%);
      margin-top: -10px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .item-label.visible {
      opacity: 1;
    }

    .item-label-name {
      font-family: var(--font-display);
      font-size: 11px;
      color: var(--champagne);
      white-space: nowrap;
    }

    .item-label-desc {
      font-size: 10px;
      color: var(--champagne);
      opacity: 0.6;
      white-space: nowrap;
    }

    /* =============================================
       CONTINUE BUTTON
       ============================================= */

    .continue-btn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      font-family: var(--font-display);
      font-size: 14px;
      color: var(--cadet-blue);
      background: var(--burnt-sienna);
      border: none;
      padding: 12px 32px;
      cursor: pointer;
      letter-spacing: 1px;
      transition: all 0.2s ease;
      display: none;
    }

    .continue-btn:hover {
      background: var(--champagne);
      box-shadow: 0 0 20px rgba(203, 120, 88, 0.5);
    }

    .continue-btn.visible {
      display: block;
    }

    /* =============================================
       DRAGGING STATE
       ============================================= */

    .dragging-item {
      position: fixed;
      z-index: 100;
      pointer-events: none;
      font-size: 32px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
      transform: translate(-50%, -50%);
    }

    body.dragging {
      cursor: grabbing !important;
    }

    body.dragging * {
      cursor: grabbing !important;
    }

    /* =============================================
       WIZARD SPEECH BUBBLE
       ============================================= */

    .wizard-speech {
      position: absolute;
      bottom: 160px;
      left: 24px;
      z-index: 15;
      max-width: 280px;
      background: rgba(39, 50, 72, 0.95);
      border: 2px solid var(--periwinkle);
      padding: 12px 16px;
      border-radius: 12px;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
    }

    .wizard-speech.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .wizard-speech::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 30px;
      border-width: 10px 10px 0;
      border-style: solid;
      border-color: var(--periwinkle) transparent transparent;
    }

    .wizard-text {
      font-size: 13px;
      color: var(--champagne);
      line-height: 1.5;
    }

    /* =============================================
       SUMMARY SCREEN
       ============================================= */

    .summary-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 50;
      background: rgba(26, 21, 16, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .summary-overlay.visible {
      display: flex;
    }

    .summary-content {
      max-width: 600px;
      text-align: center;
    }

    .summary-title {
      font-family: var(--font-display);
      font-size: 24px;
      color: var(--burnt-sienna);
      margin-bottom: 8px;
    }

    .summary-subtitle {
      font-size: 14px;
      color: var(--champagne);
      opacity: 0.7;
      margin-bottom: 32px;
    }

    .summary-selections {
      text-align: left;
      margin-bottom: 32px;
    }

    .summary-section {
      margin-bottom: 16px;
      padding: 12px 16px;
      background: rgba(39, 50, 72, 0.3);
      border-left: 3px solid var(--burnt-sienna);
      border-radius: 0 8px 8px 0;
    }

    .summary-section-label {
      font-family: var(--font-display);
      font-size: 10px;
      color: var(--burnt-sienna);
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .summary-section-value {
      font-size: 14px;
      color: var(--champagne);
    }

    .summary-actions {
      display: flex;
      gap: 16px;
      justify-content: center;
    }

    .summary-btn {
      font-family: var(--font-display);
      font-size: 12px;
      padding: 12px 24px;
      border: none;
      cursor: pointer;
      letter-spacing: 1px;
      transition: all 0.2s ease;
    }

    .summary-btn.primary {
      background: var(--burnt-sienna);
      color: var(--cadet-blue);
    }

    .summary-btn.secondary {
      background: transparent;
      color: var(--champagne);
      border: 1px solid var(--burnt-sienna);
    }

    .summary-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(203, 120, 88, 0.3);
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- Three.js Canvas -->
    <canvas id="scene-canvas"></canvas>

    <!-- Header Overlay -->
    <header class="header-overlay">
      <div class="shop-title">winded.vertigo apothecary</div>
      <div class="step-indicator" id="stepIndicator">
        <div class="step-pip" data-step="1"></div>
        <div class="step-pip" data-step="2"></div>
        <div class="step-pip" data-step="3"></div>
        <div class="step-pip" data-step="4"></div>
      </div>
      <a href="../do/" class="exit-btn">‚Üê back to menu</a>
    </header>

    <!-- Stage Prompt -->
    <div class="stage-prompt" id="stagePrompt">
      <div class="prompt-step">step 1 of 4</div>
      <div class="prompt-question">Who is your work focused on?</div>
      <div class="prompt-hint">Drag a <em>focus crystal</em> to your pouch</div>
    </div>

    <!-- Wizard Speech Bubble -->
    <div class="wizard-speech" id="wizardSpeech">
      <div class="wizard-text" id="wizardText">Welcome, traveler! I am the keeper of this apothecary. Browse my wares and gather what you need for your journey...</div>
    </div>

    <!-- Item Label (follows hovered item) -->
    <div class="item-label" id="itemLabel">
      <div class="item-label-name"></div>
      <div class="item-label-desc"></div>
    </div>

    <!-- Inventory Pouch -->
    <div class="inventory-pouch" id="inventoryPouch">
      <div class="pouch-header">
        <div class="pouch-title">Adventure Pouch</div>
        <div class="pouch-subtitle">your selections</div>
      </div>

      <!-- Step 1: Focus (single slot) -->
      <div class="inventory-section" id="section-focus">
        <div class="section-label">1. focus</div>
        <div class="slot-row">
          <div class="inventory-slot single" data-section="focus" data-index="0"></div>
        </div>
      </div>

      <!-- Step 2: Approach (single slot) -->
      <div class="inventory-section" id="section-approach">
        <div class="section-label">2. approach</div>
        <div class="slot-row">
          <div class="inventory-slot single" data-section="approach" data-index="0"></div>
        </div>
      </div>

      <!-- Step 3: Services (multi slot) -->
      <div class="inventory-section" id="section-services">
        <div class="section-label">3. services (up to 4)</div>
        <div class="slot-row">
          <div class="inventory-slot" data-section="services" data-index="0"></div>
          <div class="inventory-slot" data-section="services" data-index="1"></div>
          <div class="inventory-slot" data-section="services" data-index="2"></div>
          <div class="inventory-slot" data-section="services" data-index="3"></div>
        </div>
      </div>

      <!-- Step 4: Goals (multi slot) -->
      <div class="inventory-section" id="section-goals">
        <div class="section-label">4. goals (up to 3)</div>
        <div class="slot-row">
          <div class="inventory-slot" data-section="goals" data-index="0"></div>
          <div class="inventory-slot" data-section="goals" data-index="1"></div>
          <div class="inventory-slot" data-section="goals" data-index="2"></div>
        </div>
      </div>
    </div>

    <!-- Continue Button -->
    <button class="continue-btn" id="continueBtn">Continue ‚Üí</button>

    <!-- Summary Overlay -->
    <div class="summary-overlay" id="summaryOverlay">
      <div class="summary-content">
        <h2 class="summary-title">Your Adventure Awaits</h2>
        <p class="summary-subtitle">Here's what you've gathered from the apothecary</p>
        <div class="summary-selections" id="summarySelections"></div>
        <div class="summary-actions">
          <button class="summary-btn secondary" id="resetBtn">Start Over</button>
          <button class="summary-btn primary" id="submitBtn">Begin Journey ‚Üí</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // =============================================
    // GAME DATA
    // =============================================

    const STEPS = [
      null, // 1-indexed
      {
        id: 'focus',
        prompt: 'Who is your work focused on?',
        hint: 'Drag a <em>focus crystal</em> to your pouch',
        single: true,
        items: [
          { value: 'people', icon: 'üë•', label: 'People', desc: 'Human development & learning', color: 0x5872cb },
          { value: 'product', icon: 'üì¶', label: 'Product', desc: 'Tools, toys & experiences', color: 0xcb7858 }
        ]
      },
      {
        id: 'approach',
        prompt: 'What approach guides your work?',
        hint: 'Drag an <em>approach tome</em> to your pouch',
        single: true,
        items: [
          { value: 'design', icon: '‚ú®', label: 'Design', desc: 'Creating new solutions', color: 0x58cbb2 },
          { value: 'research', icon: 'üîÆ', label: 'Research', desc: 'Understanding & measuring', color: 0xd5d2ff }
        ]
      },
      {
        id: 'services',
        prompt: 'Which services do you seek?',
        hint: 'Drag up to <em>4 service vials</em> to your pouch',
        single: false,
        maxSelect: 4,
        items: []
      },
      {
        id: 'goals',
        prompt: 'What outcomes do you desire?',
        hint: 'Drag up to <em>3 goal stones</em> to your pouch',
        single: false,
        maxSelect: 3,
        items: [
          { value: 'awareness', icon: 'üí°', label: 'Build Awareness', desc: 'Spread understanding', color: 0xffebd2 },
          { value: 'behavior', icon: 'üéØ', label: 'Change Behavior', desc: 'Shift actions & habits', color: 0xb15043 },
          { value: 'skills', icon: '‚ö°', label: 'Develop Skills', desc: 'Build capabilities', color: 0x58cbb2 },
          { value: 'evidence', icon: 'üìä', label: 'Generate Evidence', desc: 'Prove impact', color: 0x5872cb },
          { value: 'engagement', icon: '‚ù§Ô∏è', label: 'Drive Engagement', desc: 'Create connection', color: 0xcb7858 }
        ]
      }
    ];

    const SERVICES_BY_QUADRANT = {
      'people-design': [
        { value: 'trainings', icon: 'üéì', label: 'Trainings', desc: 'Workshops & facilitation', color: 0x5872cb },
        { value: 'learning-experiences', icon: 'üåü', label: 'Learning Experiences', desc: 'Immersive programmes', color: 0x58cbb2 },
        { value: 'programmes', icon: 'üìã', label: 'Programmes', desc: 'Structured journeys', color: 0xcb7858 },
        { value: 'comms-assets', icon: 'üì¢', label: 'Comms Assets', desc: 'Materials that communicate', color: 0xd5d2ff }
      ],
      'people-research': [
        { value: 'programme-evaluation', icon: 'üìä', label: 'Programme Evaluation', desc: 'Measure impact', color: 0x5872cb },
        { value: 'mel-touchpoints', icon: 'üìç', label: 'MEL Touchpoints', desc: 'Monitoring checkpoints', color: 0x58cbb2 },
        { value: 'psychometrics', icon: 'üß†', label: 'Psychometrics', desc: 'Validated assessments', color: 0xd5d2ff },
        { value: 'evidence-for-funders', icon: 'üíº', label: 'Evidence for Funders', desc: 'Proof for stakeholders', color: 0xcb7858 }
      ],
      'product-design': [
        { value: 'learning-tools', icon: 'üõ†Ô∏è', label: 'Learning Tools', desc: 'Educational products', color: 0x5872cb },
        { value: 'toys-games', icon: 'üé≤', label: 'Toys & Games', desc: 'Play-based products', color: 0x58cbb2 },
        { value: 'comms-assets-product', icon: 'üé®', label: 'Comms Assets', desc: 'Brand materials', color: 0xcb7858 },
        { value: 'udl-improvements', icon: '‚ôø', label: 'UDL Improvements', desc: 'Accessibility upgrades', color: 0xd5d2ff }
      ],
      'product-research': [
        { value: 'exhibit-efficacy', icon: 'üèõÔ∏è', label: 'Exhibit Efficacy', desc: 'Does the exhibit work?', color: 0x5872cb },
        { value: 'toy-impacts', icon: 'üéÆ', label: 'Toy Impacts', desc: 'Play value research', color: 0x58cbb2 },
        { value: 'udl-validation', icon: '‚úÖ', label: 'UDL Validation', desc: 'Accessibility testing', color: 0xd5d2ff },
        { value: 'usability-testing', icon: 'üë§', label: 'Usability Testing', desc: 'User experience research', color: 0xcb7858 }
      ]
    };

    const WIZARD_LINES = {
      welcome: "Welcome, traveler! I am the keeper of this apothecary. Browse my wares and gather what you need for your journey...",
      step1: "Ah, choosing your focus! The crystal on the left calls to those who serve people directly. The one on the right, for those who craft products and tools.",
      step2: "Now, your approach... Do you wish to design and create anew? Or research and understand what already is?",
      step3: "Excellent choices! Now select the services that will aid your quest. Take up to four vials from the shelf.",
      step4: "Finally, what outcomes do you seek? These goal stones will guide your path. Choose up to three.",
      complete: "A fine selection! Your adventure pack is ready. May these tools serve you well on your journey!",
      dragHint: "Simply drag the items from my shelves into your pouch on the right.",
      goodChoice: ["A wise choice!", "That one has served many travelers well.", "Ah yes, a powerful selection.", "I had a feeling you'd choose that one."]
    };

    // =============================================
    // GAME STATE
    // =============================================

    const gameState = {
      step: 1,
      focus: null,
      approach: null,
      services: [],
      goals: [],
      dragging: null
    };

    // =============================================
    // THREE.JS SETUP
    // =============================================

    const canvas = document.getElementById('scene-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Colors
    const COLORS = {
      cadetBlue: 0x273248,
      redwood: 0xb15043,
      burntSienna: 0xcb7858,
      champagne: 0xffebd2,
      periwinkle: 0x5872cb,
      seafoam: 0x58cbb2
    };

    // Scene background - warm apothecary interior
    scene.background = new THREE.Color(0x1a1510);
    scene.fog = new THREE.Fog(0x1a1510, 8, 20);

    // Camera position - viewing the shop from customer perspective
    camera.position.set(0, 1.8, 5);
    camera.lookAt(0, 1.2, 0);

    // =============================================
    // LIGHTING - Warm apothecary glow
    // =============================================

    // Ambient light - dim warm
    const ambientLight = new THREE.AmbientLight(0xffebd2, 0.2);
    scene.add(ambientLight);

    // Main lantern light (overhead)
    const mainLight = new THREE.PointLight(0xffebd2, 1.2, 12);
    mainLight.position.set(0, 3.5, 1);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 1024;
    mainLight.shadow.mapSize.height = 1024;
    scene.add(mainLight);

    // Accent candle lights
    const candleLight1 = new THREE.PointLight(0xcb7858, 0.6, 5);
    candleLight1.position.set(-2, 1.8, 0);
    scene.add(candleLight1);

    const candleLight2 = new THREE.PointLight(0xcb7858, 0.6, 5);
    candleLight2.position.set(2, 1.8, 0);
    scene.add(candleLight2);

    // Mystical accent (periwinkle glow from wizard area)
    const wizardGlow = new THREE.PointLight(0x5872cb, 0.4, 6);
    wizardGlow.position.set(-3, 2, -1);
    scene.add(wizardGlow);

    // =============================================
    // APOTHECARY ENVIRONMENT
    // =============================================

    // Floor - wooden planks
    const floorGeom = new THREE.PlaneGeometry(14, 10);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x3d2a1a,
      roughness: 0.9,
      metalness: 0
    });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    // Back wall
    const backWallGeom = new THREE.PlaneGeometry(14, 5);
    const backWallMat = new THREE.MeshStandardMaterial({
      color: 0x4a3525,
      roughness: 0.85
    });
    const backWall = new THREE.Mesh(backWallGeom, backWallMat);
    backWall.position.set(0, 2.5, -2);
    backWall.receiveShadow = true;
    scene.add(backWall);

    // Side walls (partial, for depth)
    const sideWallGeom = new THREE.PlaneGeometry(6, 5);
    const leftWall = new THREE.Mesh(sideWallGeom, backWallMat);
    leftWall.position.set(-5, 2.5, 0);
    leftWall.rotation.y = Math.PI / 2;
    scene.add(leftWall);

    const rightWall = new THREE.Mesh(sideWallGeom, backWallMat);
    rightWall.position.set(5, 2.5, 0);
    rightWall.rotation.y = -Math.PI / 2;
    scene.add(rightWall);

    // Main counter/display table
    const counterGroup = new THREE.Group();

    const counterBaseGeom = new THREE.BoxGeometry(6, 0.9, 1.5);
    const counterMat = new THREE.MeshStandardMaterial({
      color: 0x5a3d2a,
      roughness: 0.7
    });
    const counterBase = new THREE.Mesh(counterBaseGeom, counterMat);
    counterBase.position.y = 0.45;
    counterBase.castShadow = true;
    counterBase.receiveShadow = true;
    counterGroup.add(counterBase);

    // Counter top
    const counterTopGeom = new THREE.BoxGeometry(6.2, 0.08, 1.7);
    const counterTopMat = new THREE.MeshStandardMaterial({
      color: 0x6b4a35,
      roughness: 0.5
    });
    const counterTop = new THREE.Mesh(counterTopGeom, counterTopMat);
    counterTop.position.y = 0.94;
    counterTop.receiveShadow = true;
    counterGroup.add(counterTop);

    counterGroup.position.set(0, 0, 0.5);
    scene.add(counterGroup);

    // Back shelving unit
    const shelfUnitGroup = new THREE.Group();

    // Shelf frame/back
    const shelfBackGeom = new THREE.BoxGeometry(5, 3, 0.1);
    const shelfFrameMat = new THREE.MeshStandardMaterial({
      color: 0x4a3525,
      roughness: 0.8
    });
    const shelfBack = new THREE.Mesh(shelfBackGeom, shelfFrameMat);
    shelfBack.position.set(0, 2.5, -1.9);
    shelfUnitGroup.add(shelfBack);

    // Create individual shelves
    function createShelf(y, width = 4.8) {
      const shelfGeom = new THREE.BoxGeometry(width, 0.08, 0.5);
      const shelfMat = new THREE.MeshStandardMaterial({
        color: 0x5a4030,
        roughness: 0.7
      });
      const shelf = new THREE.Mesh(shelfGeom, shelfMat);
      shelf.position.set(0, y, -1.6);
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      return shelf;
    }

    shelfUnitGroup.add(createShelf(1.5));
    shelfUnitGroup.add(createShelf(2.5));
    shelfUnitGroup.add(createShelf(3.5));

    scene.add(shelfUnitGroup);

    // Decorative elements - jars on background shelves (non-interactive)
    function createDecoJar(x, y, z, color) {
      const jarGroup = new THREE.Group();

      const bodyGeom = new THREE.CylinderGeometry(0.12, 0.14, 0.35, 12);
      const glassMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.25,
        roughness: 0.1
      });
      const body = new THREE.Mesh(bodyGeom, glassMat);
      jarGroup.add(body);

      const liquidGeom = new THREE.CylinderGeometry(0.1, 0.12, 0.28, 12);
      const liquidMat = new THREE.MeshStandardMaterial({
        color: color,
        transparent: true,
        opacity: 0.6,
        emissive: color,
        emissiveIntensity: 0.2
      });
      const liquid = new THREE.Mesh(liquidGeom, liquidMat);
      liquid.position.y = -0.02;
      jarGroup.add(liquid);

      const corkGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.08, 8);
      const corkMat = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
      const cork = new THREE.Mesh(corkGeom, corkMat);
      cork.position.y = 0.2;
      jarGroup.add(cork);

      jarGroup.position.set(x, y, z);
      return jarGroup;
    }

    // Background deco jars
    const decoColors = [0x5872cb, 0x58cbb2, 0xcb7858, 0xd5d2ff, 0xb15043];
    for (let i = 0; i < 8; i++) {
      const x = -1.8 + (i % 4) * 1.2;
      const y = 2.7 + Math.floor(i / 4) * 1;
      const color = decoColors[i % decoColors.length];
      scene.add(createDecoJar(x, y, -1.5, color));
    }

    // Hanging lantern
    const lanternGroup = new THREE.Group();
    const lanternFrameGeom = new THREE.BoxGeometry(0.4, 0.5, 0.4);
    const lanternFrameMat = new THREE.MeshStandardMaterial({
      color: 0x4a3020,
      roughness: 0.6
    });
    // Frame edges (simplified)
    const lanternFrame = new THREE.Mesh(
      new THREE.BoxGeometry(0.35, 0.45, 0.35),
      new THREE.MeshStandardMaterial({
        color: 0xffebd2,
        transparent: true,
        opacity: 0.3,
        emissive: 0xffebd2,
        emissiveIntensity: 0.3
      })
    );
    lanternGroup.add(lanternFrame);

    // Chain
    const chainGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 6);
    const chainMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
    const chain = new THREE.Mesh(chainGeom, chainMat);
    chain.position.y = 0.65;
    lanternGroup.add(chain);

    lanternGroup.position.set(0, 3.2, 1);
    scene.add(lanternGroup);

    // =============================================
    // WIZARD CHARACTER
    // =============================================

    const wizardGroup = new THREE.Group();

    // Body - robed figure
    const robeGeom = new THREE.ConeGeometry(0.45, 1.6, 8);
    const robeMat = new THREE.MeshStandardMaterial({
      color: COLORS.cadetBlue,
      roughness: 0.8
    });
    const robe = new THREE.Mesh(robeGeom, robeMat);
    robe.position.y = 0.8;
    robe.castShadow = true;
    wizardGroup.add(robe);

    // Upper body
    const torsoGeom = new THREE.CylinderGeometry(0.25, 0.35, 0.5, 8);
    const torso = new THREE.Mesh(torsoGeom, robeMat);
    torso.position.y = 1.65;
    torso.castShadow = true;
    wizardGroup.add(torso);

    // Head
    const headGeom = new THREE.SphereGeometry(0.2, 16, 16);
    const headMat = new THREE.MeshStandardMaterial({
      color: 0xe8d0b8,
      roughness: 0.7
    });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = 2.05;
    head.castShadow = true;
    wizardGroup.add(head);

    // Hat
    const hatGeom = new THREE.ConeGeometry(0.28, 0.6, 8);
    const hatMat = new THREE.MeshStandardMaterial({
      color: COLORS.redwood,
      roughness: 0.6
    });
    const hat = new THREE.Mesh(hatGeom, hatMat);
    hat.position.y = 2.5;
    hat.rotation.x = -0.1;
    hat.castShadow = true;
    wizardGroup.add(hat);

    // Hat brim
    const brimGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.04, 16);
    const brim = new THREE.Mesh(brimGeom, hatMat);
    brim.position.y = 2.22;
    wizardGroup.add(brim);

    // Beard
    const beardGeom = new THREE.ConeGeometry(0.15, 0.4, 8);
    const beardMat = new THREE.MeshStandardMaterial({
      color: 0xaaaaaa,
      roughness: 0.9
    });
    const beard = new THREE.Mesh(beardGeom, beardMat);
    beard.position.set(0, 1.75, 0.12);
    beard.rotation.x = Math.PI;
    wizardGroup.add(beard);

    // Staff
    const staffGeom = new THREE.CylinderGeometry(0.025, 0.035, 2, 8);
    const staffMat = new THREE.MeshStandardMaterial({
      color: 0x5a3d28,
      roughness: 0.7
    });
    const staff = new THREE.Mesh(staffGeom, staffMat);
    staff.position.set(0.4, 1, 0.1);
    staff.rotation.z = 0.1;
    wizardGroup.add(staff);

    // Staff crystal
    const staffCrystalGeom = new THREE.OctahedronGeometry(0.1, 0);
    const staffCrystalMat = new THREE.MeshStandardMaterial({
      color: COLORS.periwinkle,
      emissive: COLORS.periwinkle,
      emissiveIntensity: 0.6,
      roughness: 0.2
    });
    const staffCrystal = new THREE.Mesh(staffCrystalGeom, staffCrystalMat);
    staffCrystal.position.set(0.48, 2.05, 0.12);
    wizardGroup.add(staffCrystal);

    // Position wizard to the left side, behind counter
    wizardGroup.position.set(-2.2, 0, -0.5);
    scene.add(wizardGroup);

    // =============================================
    // 3D ITEM OBJECTS (Draggable wares)
    // =============================================

    const itemObjects = [];
    const itemDataMap = new Map();

    // Create different mystical 3D objects
    function createCrystal(color, size = 0.18) {
      const group = new THREE.Group();

      const geom = new THREE.OctahedronGeometry(size, 0);
      const mat = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.4,
        roughness: 0.15,
        metalness: 0.2
      });
      const crystal = new THREE.Mesh(geom, mat);
      crystal.castShadow = true;
      group.add(crystal);

      // Base/stand
      const baseGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.06, 8);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x4a3525 });
      const base = new THREE.Mesh(baseGeom, baseMat);
      base.position.y = -size - 0.03;
      group.add(base);

      return group;
    }

    function createPotion(color, size = 0.14) {
      const group = new THREE.Group();

      // Bottle body - rounded flask shape
      const bodyGeom = new THREE.SphereGeometry(size, 12, 12);
      bodyGeom.scale(1, 1.3, 1);
      const glassMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        roughness: 0.05,
        metalness: 0.1
      });
      const body = new THREE.Mesh(bodyGeom, glassMat);
      body.position.y = size * 0.3;
      group.add(body);

      // Neck
      const neckGeom = new THREE.CylinderGeometry(size * 0.3, size * 0.4, size * 0.5, 8);
      const neck = new THREE.Mesh(neckGeom, glassMat);
      neck.position.y = size * 1.4;
      group.add(neck);

      // Liquid inside
      const liquidGeom = new THREE.SphereGeometry(size * 0.85, 12, 12);
      liquidGeom.scale(1, 1.2, 1);
      const liquidMat = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.85,
        roughness: 0.3
      });
      const liquid = new THREE.Mesh(liquidGeom, liquidMat);
      liquid.position.y = size * 0.2;
      group.add(liquid);

      // Cork
      const corkGeom = new THREE.CylinderGeometry(size * 0.25, size * 0.3, size * 0.3, 8);
      const corkMat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.8 });
      const cork = new THREE.Mesh(corkGeom, corkMat);
      cork.position.y = size * 1.75;
      group.add(cork);

      group.castShadow = true;
      return group;
    }

    function createTome(color) {
      const group = new THREE.Group();

      // Book cover
      const coverGeom = new THREE.BoxGeometry(0.22, 0.28, 0.06);
      const coverMat = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.7
      });
      const cover = new THREE.Mesh(coverGeom, coverMat);
      group.add(cover);

      // Pages
      const pagesGeom = new THREE.BoxGeometry(0.19, 0.25, 0.04);
      const pagesMat = new THREE.MeshStandardMaterial({ color: 0xf5f0e0, roughness: 0.9 });
      const pages = new THREE.Mesh(pagesGeom, pagesMat);
      pages.position.x = 0.008;
      group.add(pages);

      // Spine
      const spineGeom = new THREE.BoxGeometry(0.015, 0.28, 0.06);
      const spineMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color).multiplyScalar(0.6)
      });
      const spine = new THREE.Mesh(spineGeom, spineMat);
      spine.position.x = -0.11;
      group.add(spine);

      // Mystical symbol on cover
      const symbolGeom = new THREE.RingGeometry(0.04, 0.055, 6);
      const symbolMat = new THREE.MeshStandardMaterial({
        color: 0xffebd2,
        emissive: color,
        emissiveIntensity: 0.4,
        side: THREE.DoubleSide
      });
      const symbol = new THREE.Mesh(symbolGeom, symbolMat);
      symbol.position.z = 0.031;
      symbol.rotation.z = Math.PI / 6;
      group.add(symbol);

      group.castShadow = true;
      return group;
    }

    function createStone(color) {
      const group = new THREE.Group();

      // Irregular stone shape using dodecahedron
      const stoneGeom = new THREE.DodecahedronGeometry(0.12, 0);
      const stoneMat = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.25,
        roughness: 0.35,
        metalness: 0.1
      });
      const stone = new THREE.Mesh(stoneGeom, stoneMat);
      stone.rotation.set(Math.random(), Math.random(), Math.random());
      stone.castShadow = true;
      group.add(stone);

      // Cloth/cushion underneath
      const cushionGeom = new THREE.CylinderGeometry(0.1, 0.12, 0.03, 8);
      const cushionMat = new THREE.MeshStandardMaterial({
        color: 0x4a3525,
        roughness: 0.9
      });
      const cushion = new THREE.Mesh(cushionGeom, cushionMat);
      cushion.position.y = -0.1;
      group.add(cushion);

      return group;
    }

    // Position items on counter for current step
    function positionItems() {
      // Remove existing items
      itemObjects.forEach(obj => scene.remove(obj));
      itemObjects.length = 0;
      itemDataMap.clear();

      const step = STEPS[gameState.step];
      if (!step) return;

      let items = step.items;

      // For step 3, get items based on quadrant
      if (gameState.step === 3 && gameState.focus && gameState.approach) {
        const quadrant = `${gameState.focus}-${gameState.approach}`;
        items = SERVICES_BY_QUADRANT[quadrant] || [];
        STEPS[3].items = items;
      }

      const itemCount = items.length;
      const spacing = Math.min(1.2, 4 / itemCount);
      const startX = -(itemCount - 1) * spacing / 2;

      items.forEach((item, index) => {
        let mesh;

        // Create appropriate 3D object based on step
        if (gameState.step === 1) {
          mesh = createCrystal(item.color, 0.2);
          mesh.position.y = 1.15;
        } else if (gameState.step === 2) {
          mesh = createTome(item.color);
          mesh.position.y = 1.08;
          mesh.rotation.x = -0.3; // Tilted for visibility
        } else if (gameState.step === 3) {
          mesh = createPotion(item.color, 0.15);
          mesh.position.y = 1.0;
        } else if (gameState.step === 4) {
          mesh = createStone(item.color);
          mesh.position.y = 1.1;
        }

        mesh.position.x = startX + index * spacing;
        mesh.position.z = 0.5; // On counter

        // Store item data
        mesh.userData = { ...item, index, originalY: mesh.position.y };
        itemDataMap.set(mesh.uuid, item);

        // Mark as draggable
        mesh.traverse(child => {
          child.userData.draggable = true;
          child.userData.itemData = item;
          child.userData.parentGroup = mesh;
        });

        scene.add(mesh);
        itemObjects.push(mesh);
      });
    }

    // =============================================
    // RAYCASTING & DRAG-AND-DROP
    // =============================================

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredItem = null;
    let draggedItemData = null;
    let draggedMesh = null;
    let draggingElement = null;

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Update item label position if hovering
      if (hoveredItem && !draggedItemData) {
        const label = document.getElementById('itemLabel');
        label.style.left = event.clientX + 'px';
        label.style.top = event.clientY + 'px';
      }

      // Update dragging element position
      if (draggingElement) {
        draggingElement.style.left = event.clientX + 'px';
        draggingElement.style.top = event.clientY + 'px';
        updateDropTargets(event.clientX, event.clientY);
      }
    }

    function updateDropTargets(x, y) {
      const step = STEPS[gameState.step];
      if (!step) return;

      const slots = document.querySelectorAll(`.inventory-slot[data-section="${step.id}"]`);
      slots.forEach(slot => {
        const rect = slot.getBoundingClientRect();
        const isOver = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        slot.classList.toggle('drop-target', isOver && !slot.classList.contains('filled'));
      });
    }

    function onMouseDown(event) {
      if (event.button !== 0) return;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      for (const intersect of intersects) {
        let obj = intersect.object;

        // Find the parent group with item data
        while (obj && !obj.userData.itemData) {
          obj = obj.parent;
        }

        if (obj && obj.userData.itemData) {
          const itemData = obj.userData.itemData;
          const parentGroup = obj.userData.parentGroup || obj;

          // Check if already selected
          const step = STEPS[gameState.step];
          if (step.single) {
            if (gameState[step.id] === itemData.value) return;
          } else {
            if (gameState[step.id].includes(itemData.value)) return;
            if (gameState[step.id].length >= step.maxSelect) return;
          }

          draggedItemData = itemData;
          draggedMesh = parentGroup;

          // Create visual dragging element
          draggingElement = document.createElement('div');
          draggingElement.className = 'dragging-item';
          draggingElement.textContent = itemData.icon;
          draggingElement.style.left = event.clientX + 'px';
          draggingElement.style.top = event.clientY + 'px';
          document.body.appendChild(draggingElement);
          document.body.classList.add('dragging');

          // Hide label
          document.getElementById('itemLabel').classList.remove('visible');

          // Fade out 3D mesh
          draggedMesh.traverse(child => {
            if (child.material) {
              child.material.transparent = true;
              child.material.opacity = 0.3;
            }
          });

          break;
        }
      }
    }

    function onMouseUp(event) {
      if (!draggedItemData) return;

      const step = STEPS[gameState.step];
      const slots = document.querySelectorAll(`.inventory-slot[data-section="${step.id}"]`);
      let dropped = false;

      slots.forEach(slot => {
        const rect = slot.getBoundingClientRect();
        const isOver = event.clientX >= rect.left && event.clientX <= rect.right &&
                       event.clientY >= rect.top && event.clientY <= rect.bottom;

        if (isOver && !slot.classList.contains('filled')) {
          dropped = true;

          // Update game state
          if (step.single) {
            gameState[step.id] = draggedItemData.value;
          } else {
            gameState[step.id].push(draggedItemData.value);
          }

          // Update slot UI
          slot.classList.add('filled');
          slot.innerHTML = `
            <div class="slot-item">${draggedItemData.icon}</div>
            <div class="slot-tooltip">${draggedItemData.label}</div>
          `;

          // Wizard reaction
          const randomLine = WIZARD_LINES.goodChoice[Math.floor(Math.random() * WIZARD_LINES.goodChoice.length)];
          showWizardSpeech(randomLine);

          // Remove from scene
          scene.remove(draggedMesh);
          const idx = itemObjects.indexOf(draggedMesh);
          if (idx > -1) itemObjects.splice(idx, 1);

          // Check progression
          checkStepComplete();
        }

        slot.classList.remove('drop-target');
      });

      // If not dropped, restore mesh
      if (!dropped && draggedMesh) {
        draggedMesh.traverse(child => {
          if (child.material) {
            child.material.opacity = 1;
          }
        });
      }

      // Clean up
      if (draggingElement) {
        draggingElement.remove();
        draggingElement = null;
      }
      document.body.classList.remove('dragging');
      draggedItemData = null;
      draggedMesh = null;
    }

    function checkHover() {
      if (draggedItemData) return;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      const label = document.getElementById('itemLabel');
      let foundItem = null;

      for (const intersect of intersects) {
        let obj = intersect.object;
        while (obj && !obj.userData.itemData) {
          obj = obj.parent;
        }
        if (obj && obj.userData.itemData) {
          foundItem = obj.userData.itemData;
          break;
        }
      }

      if (foundItem) {
        if (hoveredItem !== foundItem) {
          hoveredItem = foundItem;
          label.querySelector('.item-label-name').textContent = foundItem.label;
          label.querySelector('.item-label-desc').textContent = foundItem.desc;
          label.classList.add('visible');
        }
        canvas.style.cursor = 'grab';
      } else {
        if (hoveredItem) {
          hoveredItem = null;
          label.classList.remove('visible');
        }
        canvas.style.cursor = 'default';
      }
    }

    // =============================================
    // GAME FLOW
    // =============================================

    function checkStepComplete() {
      const step = STEPS[gameState.step];
      const continueBtn = document.getElementById('continueBtn');

      if (step.single) {
        // Single select - auto advance after brief delay
        if (gameState[step.id]) {
          setTimeout(() => advanceStep(), 600);
        }
      } else {
        // Multi select - show continue when at least 1
        if (gameState[step.id].length > 0) {
          continueBtn.classList.add('visible');
        } else {
          continueBtn.classList.remove('visible');
        }
      }
    }

    function advanceStep() {
      if (gameState.step >= 4) {
        showSummary();
        return;
      }

      gameState.step++;
      document.getElementById('continueBtn').classList.remove('visible');
      updateUI();
      positionItems();
      showWizardSpeech(WIZARD_LINES[`step${gameState.step}`] || WIZARD_LINES.dragHint);
    }

    function updateUI() {
      // Step pips
      document.querySelectorAll('.step-pip').forEach(pip => {
        const s = parseInt(pip.dataset.step);
        pip.classList.toggle('active', s === gameState.step);
        pip.classList.toggle('complete', s < gameState.step);
      });

      // Prompt
      const step = STEPS[gameState.step];
      const prompt = document.getElementById('stagePrompt');
      prompt.querySelector('.prompt-step').textContent = `step ${gameState.step} of 4`;
      prompt.querySelector('.prompt-question').textContent = step.prompt;
      prompt.querySelector('.prompt-hint').innerHTML = step.hint;

      // Inventory section opacity
      document.querySelectorAll('.inventory-section').forEach(section => {
        const id = section.id.replace('section-', '');
        const stepNum = ['focus', 'approach', 'services', 'goals'].indexOf(id) + 1;
        section.style.opacity = stepNum <= gameState.step ? '1' : '0.4';
      });
    }

    function showWizardSpeech(text) {
      const speech = document.getElementById('wizardSpeech');
      const textEl = document.getElementById('wizardText');
      textEl.textContent = text;
      speech.classList.add('visible');

      clearTimeout(window.wizardTimeout);
      window.wizardTimeout = setTimeout(() => {
        speech.classList.remove('visible');
      }, 4000);
    }

    function showSummary() {
      showWizardSpeech(WIZARD_LINES.complete);

      setTimeout(() => {
        const overlay = document.getElementById('summaryOverlay');
        const selections = document.getElementById('summarySelections');

        const focusItem = STEPS[1].items.find(i => i.value === gameState.focus);
        const approachItem = STEPS[2].items.find(i => i.value === gameState.approach);
        const serviceItems = gameState.services.map(v =>
          STEPS[3].items.find(i => i.value === v)
        ).filter(Boolean);
        const goalItems = gameState.goals.map(v =>
          STEPS[4].items.find(i => i.value === v)
        ).filter(Boolean);

        selections.innerHTML = `
          <div class="summary-section">
            <div class="summary-section-label">Focus</div>
            <div class="summary-section-value">${focusItem?.icon || ''} ${focusItem?.label || ''}</div>
          </div>
          <div class="summary-section">
            <div class="summary-section-label">Approach</div>
            <div class="summary-section-value">${approachItem?.icon || ''} ${approachItem?.label || ''}</div>
          </div>
          <div class="summary-section">
            <div class="summary-section-label">Services</div>
            <div class="summary-section-value">${serviceItems.map(i => `${i.icon} ${i.label}`).join(', ')}</div>
          </div>
          <div class="summary-section">
            <div class="summary-section-label">Goals</div>
            <div class="summary-section-value">${goalItems.map(i => `${i.icon} ${i.label}`).join(', ')}</div>
          </div>
        `;

        overlay.classList.add('visible');
      }, 500);
    }

    function resetGame() {
      gameState.step = 1;
      gameState.focus = null;
      gameState.approach = null;
      gameState.services = [];
      gameState.goals = [];

      document.querySelectorAll('.inventory-slot').forEach(slot => {
        slot.classList.remove('filled');
        slot.innerHTML = '';
      });

      document.getElementById('summaryOverlay').classList.remove('visible');
      document.getElementById('continueBtn').classList.remove('visible');

      updateUI();
      positionItems();
      showWizardSpeech(WIZARD_LINES.welcome);
    }

    // =============================================
    // ANIMATION
    // =============================================

    let time = 0;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Item bobbing
      itemObjects.forEach((obj, i) => {
        if (obj.userData.originalY !== undefined) {
          obj.position.y = obj.userData.originalY + Math.sin(time * 1.5 + i * 0.5) * 0.015;
        }
        obj.rotation.y += 0.003;
      });

      // Wizard idle animation
      wizardGroup.rotation.y = Math.sin(time * 0.3) * 0.08;
      staffCrystal.material.emissiveIntensity = 0.4 + Math.sin(time * 2) * 0.2;

      // Lantern flicker
      mainLight.intensity = 1.1 + Math.sin(time * 8) * 0.1 + Math.sin(time * 13) * 0.05;
      candleLight1.intensity = 0.5 + Math.sin(time * 6 + 1) * 0.1;
      candleLight2.intensity = 0.5 + Math.sin(time * 7 + 2) * 0.1;

      checkHover();
      renderer.render(scene, camera);
    }

    // =============================================
    // EVENT LISTENERS
    // =============================================

    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mouseup', onMouseUp);

    document.getElementById('continueBtn').addEventListener('click', advanceStep);
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    document.getElementById('submitBtn').addEventListener('click', () => {
      const params = new URLSearchParams({
        focus: gameState.focus,
        approach: gameState.approach,
        services: gameState.services.join(','),
        goals: gameState.goals.join(',')
      });
      window.location.href = `../connect/?${params.toString()}`;
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // =============================================
    // INITIALIZE
    // =============================================

    updateUI();
    positionItems();
    showWizardSpeech(WIZARD_LINES.welcome);
    animate();
  </script>
</body>
</html>
